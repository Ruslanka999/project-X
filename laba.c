#include <stdio.h>

int powerOfTwo(int x) {
    if(x == 0)
        return 1;
    return 2 * powerOfTwo(x - 1);
}

int laba1() {
    float A, B, C, P;
    
    printf("Введите A: ");
    scanf("%f", &A);
    printf("Введите B: ");
    scanf("%f", &B);
    printf("Введите C: ");
    scanf("%f", &C);
    
    P = ((A * B - C * C) / (B * C + A)) * powerOfTwo(2); 
    printf("P = %f\n", P);
    
    return 0;
}


int laba2() {
    float s = 0.0;        //// s — сумма ряда, изначально равна 0
    float a;              // текущий элемент ряда
    float x;              // входной параметр
    float epsilon;        // точность вычислений
    int sign = 1;         // знак очередного элемента ряда (+1 или -1)
    float x_power;        // текущая степень x (x^(2i+1))
    float factorial;      // текущий факториал ((2i+1)!) ((1!, 3!, 5!, ...))


    printf("Введите число x: ");
    scanf("%f", &x);
    printf("Введите точность epsilon: ");
    scanf("%f", &epsilon);

    // Присвоение начальных значений переменным
    x_power = x;        // начинаем с x^1
    factorial = 1.0;    // начальное значение факториала: 1! = 1

    // цикл for с досрочным выходом через break
    for (int i = 0; ; i++) {
        // Вычисление текущего элемента ряда
        a = x_power / factorial;
        
        float a_abs; //Функция вычисляет абсолютное значение и возвращает модуль значения 
        if (a < 0) // Проверяет, является ли значение переменной a отрицательным. 
        // Если условие истинно (a < 0), выполняется a_abs = -a;. Это преобразует a в положительное число (берет модуль). 
        //Если условие ложно (a >= 0), выполняется a_abs = a;, так как a уже неотрицательное. 
        //Переменная a_abs - Хранит абсолютное значение a. Это нужно, чтобы сравнивать величину a с epsilon независимо от знака.
        
            a_abs = -a;
        else
            a_abs = a;
        
        // Если модуль текущего элемента меньше epsilon, выходим из цикла
        if (a_abs < epsilon) {
            break; 
            //Если условие a_abs < epsilon истинно, оператор break немедленно завершает выполнение цикла, внутри которого находится этот код. 
        }

        // Прибавляем к сумме текущий элемент с учетом знака
        s += sign * a;

        // Обновление степени x: x_power переходит от x^(2i+1) к x^(2i+3)
        x_power *= x * x;

       
        factorial *= (2 * i + 2) * (2 * i + 3);
        // вычисляет произведение 2-х чисел, зависящих от счетчика i. Для того, чтобы перейти от текущего (2*i+1)! к следующему (2*i+3)! 
        //i < n логическое условие возвращает 1, если условие истинно (то есть, если i меньше n -1) и 0 , если ложно  
        // это улосвие проверяет, что мы не на последней итерации. (чтобы правильно перейти к следующему члену,необходимо обновлять факториал, умножая его на два последовательных числа, соответсвующих следующему факториалу)
        
        //(i >= n - 1) всегда ровняется единицы, она помогает остановить обновление факториала на последнем шаге, это предотвращает ненужное умножение на дополнительные множители после последнего повторения. 
        //(i < n - 1 ) факториал увеличивается на два следующих числа. Если текущий факториал равен (2i+1)!,то следующий факториал будет (2i+3)!=(2i+1)! * (2i+2)(2i+3)

        // Смена знака: умножаем на -1
        sign = -sign;
    }

    // Вывод результата
    printf("Сумма ряда: %f\n", s);

    return 0;
}

int laba3() {;  
    char s[1024];
    int ans = 0, vowels = 0, cons = 0, inword = 0;

    // Читаем строку
    if (fgets(s, sizeof(s), stdin) == NULL)
        return 1;
    
    // Проходим по символам строки
    for (int i = 0; i < 1024; i++)
    {
        char c = s[i];
        // Проверяем, является ли символ русской буквой
        if ((c >= "А" && c <= "Я") || (c >= "а" && c <= "я") || c == "ё" || c == "Ё")
        {
            inword = 1; // Находимся внутри слова
            // Проверяем, является ли буква гласной
            if (c == "а" || c == "А" || c == "е" || c == "Е" || c == "ё" || c == "Ё" || c == "и" || c == "И" || c == "о" || c == "О" || c == "у" || c == "У" || c == "ы" || c == "Ы" || c == "э" || c == "Э" || c == "ю" || c == "Ю" || c == "я" ||  c == "Я")
            {
                vowels++;
            }
            else
            {
                cons++;
            }
        }
        else
        {
            // Если встретился не-русский символ, значит слово закончилось
            if (inword)
            {
                if (vowels > cons)
                {
                    ans++; // Если в слове гласных больше, увеличиваем счётчик
                }
                inword = 0;
                vowels = 0;
                cons = 0;
            }
        }
    }

    // Проверяем последнее слово (если строка не закончилась разделителем)
    if (inword && vowels > cons)
        ans++;

    printf("%d\n", ans);
    return 0;
}

int laba4() {;
    char s[1000];  // Объявляем массив для строки
    int i = 0, w = 0;  // i - индекс чтения, w - индекс записи
    
    fgets(s, 1000, stdin);  // Читаем строку
    
    while (s[i]) {  // Пока не конец строки
        // Пропускаем пробелы и переносы
        while (s[i] == ' ' || s[i] == '\n') i++;
        
        int start = i;  // Начало слова
        
        // Ищем конец слова
        while (s[i] != ' ' && s[i] != '\n' && s[i]) i++;
        
        // Проверка на палиндром
        int is_pal = 1;
        for (int j = 0; j < (i - start)/2; j++) {
            if (s[start + j] != s[i - 1 - j]) {
                is_pal = 0;
                break;
            }
        }
        
        // Если не палиндром - копируем в результат
        if (!is_pal) {
            for (int k = start; k < i; k++) s[w++] = s[k];
            s[w++] = ' ';  // Добавляем пробел
        }
    }
    
    s[w > 0 ? w-1 : 0] = '\0';  // Удаляем последний пробел
    printf("%s", s);
    return 0;
}